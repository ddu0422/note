## 객체 지향 프로그래밍 (Object Oriented Programming)

- 객체지향 프로그래밍 이란 캡슐화, 다형성, 상속 을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것
- 유지보수를 높여서 좋은 점은?
    - 코드의 많은 변경이 없어 버그 발생 가능성을 줄일 수 있고, 시간 소모를 줄일 수 있다.
    - 비지니스 측면에서 효율적이다 (비용이 크지 않다).

## 캡슐화

- 클래스의 담은 내용을 중요한 데이터나 기능을 감춰 외부에서 사용하지 못하도록 하는 것.
- 캡슐화를 하면 좋은 이유는?
    - 외부에 불필요한 정보를 주지 않기 때문에 사용하는 곳을 줄여 유지보수를 향상시킨다.

## 상속 (확장이 더 어울린다.)

- 자식 클래스가 부모 클래스의 클래스 멤버를 물려 받는 것
- 상속을 하는 이유는?
    - 반복된 코드를 줄이고 다형성을 이용할 수 있어 유지보수를 향상시킨다.


## 다형성

- 같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질
- 다양한 객체를 같은 타입으로 선언하는 이유는?
    - 같은 타입을 상속받는(구현하는) 다른 클래스를 사용할 경우 사용하는 곳에서 코드의 변경이 많이 일어나지 않아 유지보수를 향상시킨다.


## 객체지향 생활 체조 원칙

1. 한 메서드에 오직 한 단계의 들여쓰기만 한다. (indent 를 1로 유지한다.)
2. else 예약어를 쓰지 않는다.
3. 모든 원시값과 문자열을 포장한다.
4. 한 줄에 점을 하나만 찍는다.
5. 줄여쓰지 않는다(축약 금지).
6. 모든 엔티티(객체)를 작게 유지한다.
7. 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
8. 일급 콜렉션을 쓴다.
9. 로직을 작성할 경우 게터/세터/프로퍼티를 쓰지 않는다.

## 객체지향 5원칙 (SOLID)

1. SRP (Single Responsibiliy Principle) : 단일 책임 원칙, 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 서비스는 하나의 책임을 수행해야한다.
2. OCP (Open Close Principle) : 개방 폐쇄 원칙, 소프트웨어의 구성요소는 확장에는 열려있고, 변경에는 닫혀 있어야한다.
3. LSP (The Liskov Substitution Principle) : 리스코브 치환 원칙, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야한다.
4. ISP (Interface Segregarion Principle) : 인터페이스 분리 원칙, 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않는다.
5. DIP (Dependency Inversion Principle) : 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역적 원칙, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야한다.

## GRASP (General Responsibility Assignment Software Pattern)

- 객체 설계와 책임 할당에 관한 기본적인 원리

1. Creator (생성자 패턴)
    - 상황 : 어떤 클래스의 새로운 인스턴스를 생성하는 책임(Responsibility)을 누가 가져야 할까?
    - 해법 : 다음과 같은 상황일 때 클래스 B에게 A 클래스의 인스턴스를 생성하는 책임을 부여
        - B가 A 를 포함할 때
        - B가 A 인스턴스를 기록할 때
        - B가 A 를 많이 사용할 때
        - B가 A 객체를 초기화하기 위한 데이터를 갖고 있을 때

2. Information Expert (전문가 패턴)
    - 상황 : 객체에 책임을 할당하기 위한 일반적인 원리는 무엇인가?
    - 해법 : 책임을 수행하기 위해 필요한 정보를 가장 많이 갖고 있는 객체에게 그 책임을 할당

3. Low Coupling (저결합성 패턴)
    - 상황 : 클래스 간의 낮은 의존도, 변경에 유연함, 재사용성을 높히려면 어떻게 할까?
    - 해법 : 커플링이 적게(Low Coupling) 책임을 할당
        - 커플링의 종류
            - X가 Y 인스턴스를 참조하는 **변수**를 갖고 있을 때
            - X가 Y 객체의 **서비스를 요청**할 때
            - X가 Y 의 직접, 간접적 **서브 클래스**일 때
            - X가 Y **인터페이스를 구현**했을 때

4. High Cohesion (고응집성 패턴)
    - 상황 : 너무 복잡하지 않게 하기 위해 관리를 하려면 어떻게 할까?
    - 해법 : 결합도가 높도록 책임을 할당
        - 해당 클래스가 하나의 책임을 가진다. (SRP)
        - Low Coupling이 만족되면 High Cohesion도 만족

5. Controller (제어기 패턴)
    - 상황 : UI 계층에서 사용자의 입력을 받아 처리하는 것은 누구의 책임인가?
    - 해법 : 컨트롤러를 만들어서, 컨트롤러가 사용자의 요청을 받아 로직을 분기해서 처리한다.

6. Polymorphism (다형성 패턴)
    - 상황 : 대체 가능한 소프트웨어 구성 요소들을 어떻게 생산하는가?
    - 해법 : 다형성을 이용해서 코딩하라.

7. Pure Fabrication (순수 가공 패턴)
    - 상황 : Information Expert에 근거하여, 정보가 많은 객체에 책임을 부여했는데 High Cohesion, Low Coupling이 위반될 때 어떻게 하는가?
    - 해법 : 인위적으로 어떤 클래스를 만들어서, 문제가되는 책임만 모아 High Cohesion을 갖는 클래스가 되도록 만든다.
        - Database 관련된 작업을 하는 DAO(Data Access Object) 객체를 Pure Fabrication으로 볼 수 있다.
        - 만약 유저 정보를 DB에 삽입하려하면, Information Expert에 따르면 유저정보를 갖고있는 유저 객체가 DB에 접근하는 것이 맞지만, 이는 Low Coupling, High Cohesion을 위반한다.
        - 왜냐하면, DB에 접근하는 책임이 여러 곳에 분산되기 때문이다.
        - 따라서 DAO라는 인위적인 객체를 만들고, DB에 접근하는 책임을 할당한다.

8. Indirection (간접 패턴)
    - 상황 : 두 개의 객체 간의 직접적인 커플링을 피하기 위한 책임을 어디에 할당하는가? Low Coupling, High Cohesion이 만족하도록 커플링을 피하려면 어떻게 하는가?
    - 해법 : 두 객체 사이에 중간 객체를 만든다. 
        - Adapter 
            - 사용하는 객체 - Adapter - Adapter 구현 클래스

9. Protected Variations (보호 변형 패턴)
    - 상황 : 한 요소에서의 변화나 확장이 다른 요소들에게 영향을 미치지 않도록 하려면 어떻게 하는가?
    - 해법 : 변화가 다른 곳으로 전이되는 곳에 인터페이스를 이용해서 감싸라